# 1. 栈 vs 堆

**栈的特性**：
- 先进后出
- 每个线程都有自己的线程栈，用于函数调用，但处于同一地址空间，也就是说可以访问其他线程的资源。
- 用于存放返回地址，零时变量，参数。
- 栈的内存一般都是由编译器自己来分配释放的，编译器所分配的内存是连续的，当定义一个变量的时候，在当前栈区的尾部来分配心的变量的内存。
- 在windows系统里面栈的大小是2M，在linux系统里面栈的大小是8M，可以使用ulimit-s来设置栈的大小。
- 栈的空间的分配是由高地址向低地址分配的。

**堆**： 
- 分配和释放是由程序员来分配和释放。
- 因为系统是用链表来实现空闲地址空间的，所以堆的内存空间不是连续的。
- 链表的遍历也是由低地址到高地址的，所以分配内存也是由低地址向高地址分配。

# 2. 类
## 虚函数、纯虚函数
- 主要目的是用于实现多态性，指向派生类的基类指针和引用，能够访问派生类中的同名的成员函数。动态联编，在运行时才确定该调用哪个函数。
- 虚函数表，拥有虚函数的类为每一个对象生成一个隐藏指针，指针指向虚函数表，动态联编。非虚函数是静态联编，在编译期间就确定了该调用哪个函数。
- 析构函数声明为虚函数，习惯上，若一个类中拥有虚函数，就将析构函数声明为虚函数，否则，当指向派生类的基类指针析构时，只调用了基类的析构函数，造成派生类中的动态分配的空间内存泄漏。
- 纯虚函数，为了实现抽象类，定义接口，由派生类实现，且派生类必须实现纯虚函数，抽象类不允许实例化，在声明后面加上`=0`.

## private, protected, public
- private：只有当前类可以访问
- protected：当前类极其派生类
- public：实例也可以访问


# 3. STL
## vector
vector扩容，vs编译器以1.5倍扩容，gcc/g++以两倍扩容。
- 2倍扩容缺陷，最新的大小总是大于之前分配的总和，使用1.5可能在几次分配之后用到了之前释放的空间。
- `resize` vs `reserve`，resize是改变容器大小，创建对象，而reserve是预留空间。

# c++基础
## `malloc`
- 开辟空间小于128K时，采用`brk`，从堆中分配空间(数据段.data高地址指针)
- 开辟空间大于128K时，采用`mmap`，从虚拟地址空间开辟空间(堆和栈，称为文件映射区)
分配的都是虚拟内存，没有分配物理内存，第一次访问虚拟地址空间时，发生缺页中断，操作系统负责分配物理内存，然后建立虚拟内存和物理内存之间的映射关系。

# 操作系统
## 用户态 vs 内核态
- 用户态：
一个进程执行自己得代码时处于用户运行态，特权级最低为3。
切换方式：
- 系统调用：用户进程主动发起，strace
- 异常：缺页异常等
- 外围设备中断：IO读写完成等

## 系统调用
`mmap`, `write`, `read`, `write`
- `write`: 将数据从内核缓冲区复制到应用缓冲区，然后从应用缓冲区复制到内核缓冲区
- `mmap`: 直接将数据从映射地址空间的一个内核缓冲区复制到另一个内核缓冲区。
当引用不存在的内存页时，就会发生缺页。

- `read/write`：
    - 访问文件，涉及到用户态到内核态的转换
    - 读取硬盘文件中的对应数据，按页预读到page cache中
    - 将read中需要的数据，从page cache拷贝到用户缓冲区。
- `mmap`：
    - 将硬盘文件映射到内存中，也就是将page cache中的页映射到用户进程地址空间，从而进程可以直接访问自身地址空间的虚拟地址来访问page cache中的页，就不涉及page cache与用户缓冲区之间的拷贝。。
    - 只需要一次系统调用