[TOC]
# 数据结构
## Simple dynamic string
Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。

SDS除了用来保存数据库中的字符串值，还可以用作缓冲区(AOF缓冲区、客户端中的输入缓冲区)
```c++
struct sdshdr{
    int len; // 已使用，char字符串中的`\0`不计算在在len中，
    int alloc; // 总大小
    char buf[];
};
```
### sds/c字符串
1. O(1)获取字符串长度
2. 避免了缓冲区溢出，复制字符串时，若空间不足，则先扩展，再拼接。
3. 减少修改字符串长度时所需的内存重分配次数。
4. 二进制安全。
5. 兼容部分C字符串函数。

### 空间预分配
当预留空间不足时，sds增长会进行空间分配，会为SDS分配额外的未使用空间，若增长后的长度小于1M，则预留实际分配长度的空间，即sds实际大小为实际分配的两倍，否则，sds实际大小为实际分配的空间+1M。（以上所述实际分配空间不包含'\0'，实际上应当加1。

### 惰性空间释放
不释放空间，而是作为未使用空间。

### 二进制安全
C字符串不能包含空字符，因此只能保存文本数据，不能保存像图片、音频、视频、压缩文件等二进制数据。

SDS是用len值来判断字符串是否结束。但buf仍然按照C字符串的格式(将末尾置未空字符)，使得保存文本的SDS可以重用`string.h`库定义的部分函数。

## 链表
当一个列表键包含了数量比较多的元素时，又或者列表中包含的元素都是比较长的字符串时，就会采用链表作为列表键的底层实现。

```c++
typedef struct listNode{
    struct listNode* prev;
    struct listNode* next;
    void *value;
} listNode;
typedef struct list{
    listNode* head;
    listNode* tail;
    unsigned long len;
    void* (*dup)(void *ptr); // 复制节点所保存的值
    void* (*free)(void *ptr); // 释放节点所保存的值
    void* (*match)(void *ptr, void *key); // 对比节点所保存的值是否与输入key相等
} list;
```
### 链表特性
1. 链表被广泛用于实现Redis的各种功能，如列表键、发布订阅、慢查询、监视器等
2. 双向无环链表
3. 函数指针实现多态

## 字典
字典使用哈希表作为底层实现
```c++
//dict key-value
typedef struct dictEntry{
    void *key;
    union{
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;
// hash table
typedef struct dictht{
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;
typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);
    void *(*keyDup)(void* privdata, const void *key);
    void *(*valDup)(void* privdata, const void *obj);
    int (*keyCompare)(void* privdata, const void *key1, const void *key2);
    void (*keyDestructor)(void* privdata, void* key);
    void (*valDestructor)(void* privdata, void* obj);
} dictType;

typedef struct dict{
    dictType *type;
    void *privdata;
    dictht ht[2]; // rehash相关
    long rehashidx; // rehash相关，记录rehash进度，若没有进行rehash，则为1
    unsigned long iterators;
} dict;
```
![](http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000345.jpg)

### 冲突解决
拉链法，且每次都添加到链表头部。

### rehash
1. 为字典的`ht[1]`哈希表分配空间，空间大小取决于要执行的操作，以及`ht[0]`当前包含的键值对数量(`ht[0].used`)。
   1. 若为扩展，则`ht[1]`为第一个大于等于`ht[0].used*2`的`2^n`。
   2. 若为收缩，则`ht[1]`为第一个大于等于`ht[0].used`的`2^n`。
2. 将保存在`ht[0]`中的所有键值对rehash到`ht[1]`上。
3. 当`ht[0]`包含的所有键值对都迁移到了`ht[1]`之后，释放`ht[0]`，将`ht[1]`设置为`ht[0]`，并新建一个`ht[1]`空白哈希表，为下一次rehash做准备。

### rehash触发
负载因子计算公式
$load_factor = ht[0].used / ht[0].size$

1. 服务器目前没有在执行`BGSAVE`或`BGREWRITEAOF`，并且哈希表的负载因子大于等于1。
2. 服务器目前正在执行`BGSAVE`或`BGREWRITEAOF`，并且哈希表的负载因子大于等于5。
3. 当哈希表负载因子小于0.1时，执行收缩操作。

在执行`BGSAVE`或`BGREWRITEAOF`过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统采用CoW(copy on write)来优化紫禁城的使用效率，所以在进程存在期间，服务器会提高扩展操作所需的负载因子，从而尽可能避免在子进程存在期间进行哈希表扩展操作，尽可能避免不必要的内存写入操作，最大限度地节约内存。

### 渐进式rehash
如果`ht[0]`中包含百万、千万级别的键值对，则不可能一次性将这些键值对都rehash到`ht[1]`。

在rehash执行过程中，先查找`ht[0]`在查找`ht[1]`。新增键值对都保存到`ht[1]`中。

1. 为`ht[1]`分配空间，让字典同时拥有`ht[0]`和`ht[1]`两个哈希表。
2. 在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。
3. 在rehash期间，每次对字典执行添加、删除、查找、更新操作时，还会顺带将`ht[0]`哈希表在rehashidx索引上的所有键值对rehash到`ht[1]`，当rehash工作完成后，程序将rehashidx属性的值增一。
4. 当`ht[0]`的所有键值对都被rehash到`ht[1]`，将rehashidx属性的值设为-1，表示操作已经完成。


### 字典总结
1. 字典用于实现Redis的各种功能，如数据库或哈希键。
2. 字典使用hash表作为底层实现，每个字典都带有两个哈希表，一个存储，一个用作rehash。

## 跳表
平均查找时间复杂度`O(logN)`，最坏情况`O(N)`。

Redis使用跳表来作为有序集合键的，如果一个有序集合中包含的元素数量比较多，又或者一个有序集合中元素的成员是比较长的字符串时，会采用跳表来实现。

有序集合键和集群节点中用作内部数据结构，除此之外，跳表在Redis里面没有其他用途。

![](http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000365.jpg)


```c++
typedef struct zskiplistNode {
    sds ele;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;

typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;

typedef struct zset {
    dict *dict; // dict中key为元素，value为score，所以可以实现O(1)时间查找分值。
    zskiplist *zsl;
} zset;
```
跳表：
1. header：指向跳表的表头
2. tail：指向跳表的表尾
3. level：记录目前跳表内，层数最大的节点的层数。
4. length：记录跳表的长度，即跳表目前包含的节点数量。

跳表节点：
1. score：节点分值
2. backward：后退指针
3. level：层，包含前进指针和跨度。跨度记录前进指针所指节点与当前节点的距离。
4. ele：成员对象

#### 层
每次创建一个新的跳表节点，都会根据幂次定律(越大的数出现的概率越小)，随机生成一个介于1和32之间的值作为level数组的而大小。

#### 前进指针
每层都有一个指向表尾方向的前进指针，用于从表头到表尾访问节点。

遍历时，从高层向下，访问跨度为一的下一个节点，否则就下降层数。

#### 分值和成员
分值是一个double类型的浮点数，所有节点按照分值从小到大排序。

节点的成员对象是一个sds对象，在同一个跳表中，节点保存的成员对象必须唯一，但是节点保存的分值却可以相同，分值相同的节点按照成员对象在字典序中的大小进行排序。

### 跳表总结
1. 跳表是有序集合的底层实现之一。
2. 每个跳表节点的层高都是1到32之间的随机数。
3. 在同一个条表中，多个节点可以包含相同的分支，但每个结点的成员对象必须唯一。
4. 节点按照分值大小排序，分值相同时，节点按照成员对象的大小进行排序。

## 整数集合
整数集合是集合键的底层实现之一，当一个集合只包含整数数值元素，且集合的元素数量不多，就会使用整数集合作为集合键的底层实现。

```c++
typedef struct intset {
    uint32_t encoding;
    uint32_t length;  //元素数量即contents的长度
    int8_t contents[];  //有序数组，真正类型取决于encoding
} intset;
```

### 整数升级
将一个新元素添加到整数集合中，并且新元素的类型要比整数集合现有所有元素的类型都要长时，整数集合需要进行升级，然后才能将新元素添加到集合中。

1. 根据新元素的类型，扩展整数集合底层数组的空间大小，为新元素分配空间。
2. 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到对应的位置上，并且要维持底层数组的有序性不变。
3. 将新元素添加到底层数组里面。

添加新元素的时间复杂度为O(n)。

因为引发升级的新元素的长度总是比整数集合中现有所有元素的长度都大，因此这个新元素的值要大于所有现有元素，要么小于所有现有元素。即放在数组头或尾。

不会进行降级。

### 整数集合总结
1. 整数集合是集合键的底层实现之一。
2. 底层实现为数组，这个数组以有序、无重复的方式保存集合元素，根据新加入元素的类型，改变数组的类型。
3. 升级操作为整数集合带来了操作性上的灵活性，并尽可能节约了内存。
4. 整数集合支持升级，不支持降级。

## 压缩列表
压缩列表是列表键和哈希键的底层实现之一，当一个列表键只包含少量列表项，并且每个列表要么是小整数值要么是比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。当一个哈希键只包含少量键值对时，并且每个键值对的键和值要么是小整数要么是较短的字符串，就会使用Redis来做哈希键的底层实现。

为了节约内存，有一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或一个整数值。

```c++
//<zlbytes> <zltail> <zllen> <entry> <entry> ... <entry> <zlend>
```
1. zltypes(uint32_t)：记录整个压缩列表所占用的内存字节数，再对压缩列表进行内存重新分配或计算zlend的位置时使用
2. zltail(uint32_t)：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，无需遍历就可以确定表尾节点的地址
3. zllen(uint16_t)：记录压缩列表的节点数量，当这个属性值小于UINT16_MAX时，表示节点数量，当等于UINT16_MAX时，需要遍历整个压缩列表才可以得到节点数量。
4. entryX：列表节点
5. zlend(uint8_t)：特殊值0xFF，用于标记压缩列表的末端。

### 压缩列表节点
```c++
previous_entry_length // 以字节为单位，记录压缩列表中前一个节点的长度。可以是1字节(长度小于254)或5字节(大于等于254，第一字节色号职位0xFE，后续四个字节才是真正保存长度)
encoding  //记录节点的content属性所保存数据类型以及长度(1,2,5字节可选)
content // 可以是一个字节数组也可以是一个整数。
```

可以通过`previous_entry_length`来反向遍历节点。

### 连锁更新
当新增或删除一个节点后，引起下一个节点中`previous_entry_length`字段从1字节增长为5字节，导致下一个节点长度大于等于254，将导致后续节点同样进行扩展，这一连续多次空间扩展操作称之为连锁更新。

连锁更新，最坏情况下，对压缩列表执行N次空间重分配，每次分配的最坏时间复杂度为O(N)，所以连锁更新的最坏时间复杂度是O(N)。

但其实在实际中，节点恰好有多个连续介于250-253字节之间的并不多。因此即使出现连锁更新，更新的节点数目不会特别多。

因此ziplistPush等命令的时间复杂度为O(N)。

### 压缩列表总结
1. 压缩列表是一种为节约内存而开发的顺序型数据结构。
2. 压缩列表被用作列表键和哈希键的底层实现之一。
3. 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或整数值。
4. 添加新节点到压缩列表，或从压缩列表中删除节点，可能会引发连锁更新操作。

## 对象
字符串对象、哈希对象、列表对象、集合对象、有序集合对象。

Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。

### 对象类型及编码
当在Redis中创建一个键值对时，至少会创建两个对象，键对象和值对象。
```c++
typedef struct redisObject{
    unsigned type:4;  //类型
    unsigned encoding:4;   // 编码
    unsigned lru:LRU_BITS; // 
    int refcount; // 引用计数
    void* ptr; // 数据结构指针
} robj;
```

### 类型

`TYPE`命令返回结果为数据库键对应的值对象的类型，而不是键对象的类型。只有五种。

OBJECT ENCODING可以查看一个数据库键对应的值对象的编码。

### 编码与实现
encoding记录了对象所使用的编码，即这个对象使用了什么数据结构作为对象的底层实现。

| 编码常量                  | 底层数据结构    |
| ------------------------- | --------------- |
| REDIS_ENCODING_INT        | long类型的整数  |
| REDIS_ENCODING_EMBSTR     | embstr编码的SDS |
| REDIS_ENCODING_RAW        | SDS             |
| REDIS_ENCODING_HT         | 字典            |
| REDIS_ENCODING_LINKEDLIST | 双端链表        |
| REDIS_ENCODING_ZIPLIST    | 压缩列表        |
| REDIS_ENCODING_INTSET     | 整数集合        |
| REDIS_ENCODING_SKIPLIST   | 跳表和字典      |



STRING：整数值实现、embstr编码的SDS、以及SDS实现。

LIST：压缩列表、双端队列

HASH：压缩列表、字典

SET：整数集合、字典

ZSET：压缩列表、跳表+字典

### 字符串对象
若保存的是整数值，则可以用long类型来表示。

字符串值的长度大于32字节时，采用SDS来保存(RAW)。

字符串值的长度小于等于32时，采用embstr编码的SDS来保存。

RAW编码会调用两次分配函数分别创建RedisObject和sdshdr结构，而embstr通过调用一次内存分配函数来分配一块连续的空间，分别包含两个结构。释放同理。

embstr地址连续，缓存优势。

浮点数在Redis中同样是通过字符串值来保存的。

#### 编码转换
int型转换为raw。

embstr是只读的，不能进行修改。对其进行修改时，先将其编码从embstr转为raw，再执行修改命令。

### 列表对象
压缩列表或双端链表实现。

#### 编码转换
同时满足以下两个条件时，采用压缩列表编码，这两个值是可以修改的。
1. 列表对象保存的所有字符串元素的长度都小于64
2. 列表对象保存的元素数量小于512个

### 哈希对象
压缩列表或字典实现。

压缩列表始终保存新元素在队尾。键值对象时连续存放的，键对象在前，值对象在后。

#### 编码转换
同时满足以下两个条件，采用压缩列表编码，这两个值是可以修改的。
1. 列表对象保存的所有键值对的键和值的字符串长度都小于64
2. 列表对象保存的元素数量小于512个

### 集合对象
整数集合或字典

字典的值被设置为NULL。

#### 编码转换
当集合对象可以同时满足以下两个条件时，对象使用intset编码：
1. 集合对象保存的所有元素都是整数值；
2. 集合对象保存的元素数量不超过512个。

不能满足这两个条件的集合对象需要使用hashtable编码。

### 有序集合对象
压缩列表或跳表+字典

压缩列表集合元素从小到大排序，分值较小的靠近表头。

字典实现O(1)查找分值，跳表实现O(logN)查找元素，以及O(N)遍历执行范围操作。

#### 编码转换
当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：

1. 有序集合保存的元素数量小于128个；
2. 有序集合保存的所有元素成员的长度都小于64字节；

不能满足以上两个条件的有序集合对象将使用skiplist编码。

### 类型检查和命令多态
命令分为两种，一种是可以对任何类型的键执行，如`DEL、EXPIRE、RENAME、TYPE、OBJECT`等。

一种是只能对特定类型的键执行，如：

1. 字符串键：`SET、GET、APPEND、STRLEN`等
2. 哈希键：`HDEL、HSET、HGET、HLEN`等
3. 列表键：`RPUSH、LPOP、LINSERT、LLEN`等
4. 集合键：`SADD、SPOP、SINTER、SCARD`等
5. 有序集合键：`ZADD、ZCARD、ZRANGK、ZSCORE`等

#### 类型检查
再执行一个类型特定命令前，会检查数据库键的值对象是否为执行命令所需的类型，否则拒绝执行并返回一个错误。

#### 多态命令的实现
同一命令对于不同编码的实现调用是不同的。

### 内存回收
引用计数来实现，当计数值为0时，所占用的内存会被释放。

### 对象共享
Redis只会共享整数值字符串对象以及Redis经常返回的一些命令响应字符串。包含字符串对象的其他对象同样会共享整数值对象。

对于字符串对象和包含字符串对象的其他对象，并不会进行共享，这是因为进行共享，首先需要判断二者是相同的，对于字符串对象时间复杂度为O(N)，对于其他包含字符串对象的时间复杂度为O(N^2)。

### 对象空转时长
`lru`记录了对象最后一次背命令程序访问的时间。当服务器占用内存超过maxmemory设置的上限时，空转时常较高的那部分键会优先被服务器释放。

# 单机数据库的实现
## 数据库
### 服务器中的数据库
Redis将所有数据库都保存在服务器状态`redisServer`结构的db数组中，db数组的每个项都是一个`redisDb`结构。

`dbnum`决定应该创建多少个数据库，默认选项值为16。

### 数据库切换
每个客户端都有自己的目标数据库，默认为0，可以通过select进行切换，`redisClient`中的db记录了当前的目标数据库。

```shell
select db_id //切换数据库
```

### 数据库键空间
Redis是一个key-value数据库，每个数据库都由`redisDb`结构表示，`redisDb`结构的dict字典保存了数据中的所有键值对，这个字典称为键空间。

键空间的每个键都是一个字符串对象，值可以是字符串对象、列表对象、哈希对象、集合对象和有序集合对象。

#### 键空间操作
`FLUSHDB`清空数据库，删除键空间中的所有键值对。
`RANDOMKEY`随即返回数据库中的某个键。
`DBSIZE`返回数据库中键数量。

#### 读写键空间时的维护操作
读写一个键后，会根据键是否存在更新服务器的键空间命中次数或miss次数。

读写一个键后，更新键的LRU。

在读写一个键时发现键国企，会先删除这个过期键，然后才执行余下操作。

`WATCH`监视某个键，当服务器对该键修改之后，会将这个键标记为脏，从而让事务程序注意到这个键已经被修改。

每修改一个键之后，都会对脏键计数器值增1，并触发服务器的持久化以及复制操作。

如果服务器开启了数据库通知功能，那么对键进行修改之后，服务器将按配置发送相应的数据库通知。

### 设置键的生存时间或过期时间
`EXPIRE/PEXPIRE`可以以秒或毫秒为精度为数据库的某个键设置生存时间(TTL)，在指定时间过后，服务器会自动删除生存时间为0的键。

`EXPIREAT/PEXPIREAT`可以以秒或毫秒为精度为数据库的某个键设置过期时间(TTL)，当过期时间来临时，服务器就会删除这个键。

`TTL/PTTL`可以接受一个带有生存时间或过期时间的键，返回这个键的剩余生存时间。

SETX可以设置一个字符串键的同时为键设置过期时间。

#### 设置过期时间
`EXPIRE<key><ttl>`命令用于将键key的生存时间设置为ttl秒。

`PEXPIRE<key><ttl>`命令用于将键key的生存时间设置为ttl毫秒。

`EXPIREAT<key><timestamp>`命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。

`PEXPIREAT<key><timestamp>`命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。

都是通过`PEXPIREAT`命令来实现的。

#### 保存过期时间
redisDb的expires字典保存了数据库中所有键的过期时间。

过期字典的键是一个指针，指针指向键空间中的某个键对象。

值是一个long long类型的整数，保存了数据库的过期时间，一个毫秒精度的UNIX时间戳。

#### 移除过期时间
`PERSIST`移除一个键的过期时间

# Reids在游戏业务中的应用
游戏一般会使用mongoDB或者Mysql存储游戏信息，但数据存放在硬盘中，读取速度较慢，采用Redis，提高读写速度。

## Cache
Reids缓存简要信息如(在线状态、等级等部分信息)。

## 业务状态
数据量较小，或数据量较大但数据访问频率特别高。

## 避免大Key
大Key表示一个Key对应的value非常大，比如记录玩家的当前在线状态，用一个key为`online_status`的hashmap存储了所有玩家的在线信息`uid:status`。应当拆分为每个玩家做成一个`key-value`的方式，key为`online_status_{uid}`，value为是否在线。原因是Redis是基于Key来做分布式的，若创建了一个大Key，会导致分布式功能失效，所有的请求都会到达同一个Redis节点。

无法检测。

## 避免HotKey
某个Key读写频率很高，繁忙。可以检测。