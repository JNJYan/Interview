[TOC]
# 数据结构
## Simple dynamic string
Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。

SDS除了用来保存数据库中的字符串值，还可以用作缓冲区(AOF缓冲区、客户端中的输入缓冲区)
```c++
struct sdshdr{
    int len; // 已使用，char字符串中的`\0`不计算在在len中，
    int alloc; // 总大小
    char buf[];
};
```
### sds/c字符串
1. O(1)获取字符串长度
2. 避免了缓冲区溢出，复制字符串时，若空间不足，则先扩展，再拼接。
3. 减少修改字符串长度时所需的内存重分配次数。
4. 二进制安全。
5. 兼容部分C字符串函数。

### 空间预分配
当预留空间不足时，sds增长会进行空间分配，会为SDS分配额外的未使用空间，若增长后的长度小于1M，则预留实际分配长度的空间，即sds实际大小为实际分配的两倍，否则，sds实际大小为实际分配的空间+1M。（以上所述实际分配空间不包含'\0'，实际上应当加1。

### 惰性空间释放
不释放空间，而是作为未使用空间。

### 二进制安全
C字符串不能包含空字符，因此只能保存文本数据，不能保存像图片、音频、视频、压缩文件等二进制数据。

SDS是用len值来判断字符串是否结束。但buf仍然按照C字符串的格式(将末尾置未空字符)，使得保存文本的SDS可以重用`string.h`库定义的部分函数。

## 链表
当一个列表键包含了数量比较多的元素时，又或者列表中包含的元素都是比较长的字符串时，就会采用链表作为列表键的底层实现。

```c++
typedef struct listNode{
    struct listNode* prev;
    struct listNode* next;
    void *value;
} listNode;
typedef struct list{
    listNode* head;
    listNode* tail;
    unsigned long len;
    void* (*dup)(void *ptr); // 复制节点所保存的值
    void* (*free)(void *ptr); // 释放节点所保存的值
    void* (*match)(void *ptr, void *key); // 对比节点所保存的值是否与输入key相等
} list;
```
### 链表特性
1. 链表被广泛用于实现Redis的各种功能，如列表键、发布订阅、慢查询、监视器等
2. 双向无环链表
3. 函数指针实现多态

## 字典
字典使用哈希表作为底层实现
```c++
//dict key-value
typedef struct dictEntry{
    void *key;
    union{
        void *val;
        uint64_t u64;
        int64_t s64;
        double d;
    } v;
    struct dictEntry *next;
} dictEntry;
// hash table
typedef struct dictht{
    dictEntry **table;
    unsigned long size;
    unsigned long sizemask;
    unsigned long used;
} dictht;
typedef struct dictType {
    uint64_t (*hashFunction)(const void *key);
    void *(*keyDup)(void* privdata, const void *key);
    void *(*valDup)(void* privdata, const void *obj);
    int (*keyCompare)(void* privdata, const void *key1, const void *key2);
    void (*keyDestructor)(void* privdata, void* key);
    void (*valDestructor)(void* privdata, void* obj);
} dictType;

typedef struct dict{
    dictType *type;
    void *privdata;
    dictht ht[2]; // rehash相关
    long rehashidx; // rehash相关，记录rehash进度，若没有进行rehash，则为1
    unsigned long iterators;
} dict;
```
![](http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000345.jpg)

### 冲突解决
拉链法，且每次都添加到链表头部。

### rehash
1. 为字典的`ht[1]`哈希表分配空间，空间大小取决于要执行的操作，以及`ht[0]`当前包含的键值对数量(`ht[0].used`)。
   1. 若为扩展，则`ht[1]`为第一个大于等于`ht[0].used*2`的`2^n`。
   2. 若为收缩，则`ht[1]`为第一个大于等于`ht[0].used`的`2^n`。
2. 将保存在`ht[0]`中的所有键值对rehash到`ht[1]`上。
3. 当`ht[0]`包含的所有键值对都迁移到了`ht[1]`之后，释放`ht[0]`，将`ht[1]`设置为`ht[0]`，并新建一个`ht[1]`空白哈希表，为下一次rehash做准备。

### rehash触发
负载因子计算公式
$load_factor = ht[0].used / ht[0].size$

1. 服务器目前没有在执行`BGSAVE`或`BGREWRITEAOF`，并且哈希表的负载因子大于等于1。
2. 服务器目前正在执行`BGSAVE`或`BGREWRITEAOF`，并且哈希表的负载因子大于等于5。
3. 当哈希表负载因子小于0.1时，执行收缩操作。

在执行`BGSAVE`或`BGREWRITEAOF`过程中，Redis需要创建当前服务器进程的子进程，而大多数操作系统采用CoW(copy on write)来优化紫禁城的使用效率，所以在进程存在期间，服务器会提高扩展操作所需的负载因子，从而尽可能避免在子进程存在期间进行哈希表扩展操作，尽可能避免不必要的内存写入操作，最大限度地节约内存。

### 渐进式rehash
如果`ht[0]`中包含百万、千万级别的键值对，则不可能一次性将这些键值对都rehash到`ht[1]`。

在rehash执行过程中，先查找`ht[0]`在查找`ht[1]`。新增键值对都保存到`ht[1]`中。

1. 为`ht[1]`分配空间，让字典同时拥有`ht[0]`和`ht[1]`两个哈希表。
2. 在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。
3. 在rehash期间，每次对字典执行添加、删除、查找、更新操作时，还会顺带将`ht[0]`哈希表在rehashidx索引上的所有键值对rehash到`ht[1]`，当rehash工作完成后，程序将rehashidx属性的值增一。
4. 当`ht[0]`的所有键值对都被rehash到`ht[1]`，将rehashidx属性的值设为-1，表示操作已经完成。


### 字典总结
1. 字典用于实现Redis的各种功能，如数据库或哈希键。
2. 字典使用hash表作为底层实现，每个字典都带有两个哈希表，一个存储，一个用作rehash。

## 跳表
平均查找时间复杂度`O(logN)`，最坏情况`O(N)`。

Redis使用跳表来作为有序集合键的，如果一个有序集合中包含的元素数量比较多，又或者一个有序集合中元素的成员是比较长的字符串时，会采用跳表来实现。

有序集合键和集群节点中用作内部数据结构，除此之外，跳表在Redis里面没有其他用途。

![](http://www.54manong.com/ebook/%E5%A4%A7%E6%95%B0%E6%8D%AE/20181208232851/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%20(%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF%E4%B8%9B%E4%B9%A6)-%E9%BB%84%E5%81%A5%E5%AE%8F%20%E8%91%97/images/000365.jpg)


```c++
typedef struct zskiplistNode {
    sds ele;
    double score;
    struct zskiplistNode *backward;
    struct zskiplistLevel {
        struct zskiplistNode *forward;
        unsigned long span;
    } level[];
} zskiplistNode;

typedef struct zskiplist {
    struct zskiplistNode *header, *tail;
    unsigned long length;
    int level;
} zskiplist;

typedef struct zset {
    dict *dict; // dict中key为元素，value为score，所以可以实现O(1)时间查找分值。
    zskiplist *zsl;
} zset;
```
跳表：
1. header：指向跳表的表头
2. tail：指向跳表的表尾
3. level：记录目前跳表内，层数最大的节点的层数。
4. length：记录跳表的长度，即跳表目前包含的节点数量。

跳表节点：
1. score：节点分值
2. backward：后退指针
3. level：层，包含前进指针和跨度。跨度记录前进指针所指节点与当前节点的距离。
4. ele：成员对象

#### 层
每次创建一个新的跳表节点，都会根据幂次定律(越大的数出现的概率越小)，随机生成一个介于1和32之间的值作为level数组的而大小。

#### 前进指针
每层都有一个指向表尾方向的前进指针，用于从表头到表尾访问节点。

遍历时，从高层向下，访问跨度为一的下一个节点，否则就下降层数。

#### 分值和成员
分值是一个double类型的浮点数，所有节点按照分值从小到大排序。

节点的成员对象是一个sds对象，在同一个跳表中，节点保存的成员对象必须唯一，但是节点保存的分值却可以相同，分值相同的节点按照成员对象在字典序中的大小进行排序。

### 跳表总结
1. 跳表是有序集合的底层实现之一。
2. 每个跳表节点的层高都是1到32之间的随机数。
3. 在同一个条表中，多个节点可以包含相同的分支，但每个结点的成员对象必须唯一。
4. 节点按照分值大小排序，分值相同时，节点按照成员对象的大小进行排序。

## 整数集合
整数集合是集合键的底层实现之一，当一个集合只包含整数数值元素，且集合的元素数量不多，就会使用整数集合作为集合键的底层实现。

```c++
typedef struct intset {
    uint32_t encoding;
    uint32_t length;  //元素数量即contents的长度
    int8_t contents[];  //有序数组，真正类型取决于encoding
} intset;
```

### 整数升级
将一个新元素添加到整数集合中，并且新元素的类型要比整数集合现有所有元素的类型都要长时，整数集合需要进行升级，然后才能将新元素添加到集合中。

1. 根据新元素的类型，扩展整数集合底层数组的空间大小，为新元素分配空间。
2. 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到对应的位置上，并且要维持底层数组的有序性不变。
3. 将新元素添加到底层数组里面。

添加新元素的时间复杂度为O(n)。

因为引发升级的新元素的长度总是比整数集合中现有所有元素的长度都大，因此这个新元素的值要大于所有现有元素，要么小于所有现有元素。即放在数组头或尾。

不会进行降级。

### 整数集合总结
1. 整数集合是集合键的底层实现之一。
2. 底层实现为数组，这个数组以有序、无重复的方式保存集合元素，根据新加入元素的类型，改变数组的类型。
3. 升级操作为整数集合带来了操作性上的灵活性，并尽可能节约了内存。
4. 整数集合支持升级，不支持降级。

## 压缩列表
压缩列表是列表键和哈希键的底层实现之一，当一个列表键只包含少量列表项，并且每个列表要么是小整数值要么是比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。当一个哈希键只包含少量键值对时，并且每个键值对的键和值要么是小整数要么是较短的字符串，就会使用Redis来做哈希键的底层实现。

为了节约内存，有一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或一个整数值。

```c++
//<zlbytes> <zltail> <zllen> <entry> <entry> ... <entry> <zlend>
```
1. zltypes(uint32_t)：记录整个压缩列表所占用的内存字节数，再对压缩列表进行内存重新分配或计算zlend的位置时使用
2. zltail(uint32_t)：记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，无需遍历就可以确定表尾节点的地址
3. zllen(uint16_t)：记录压缩列表的节点数量，当这个属性值小于UINT16_MAX时，表示节点数量，当等于UINT16_MAX时，需要遍历整个压缩列表才可以得到节点数量。
4. entryX：列表节点
5. zlend(uint8_t)：特殊值0xFF，用于标记压缩列表的末端。

### 压缩列表节点
```c++
previous_entry_length // 以字节为单位，记录压缩列表中前一个节点的长度。可以是1字节(长度小于254)或5字节(大于等于254，第一字节色号职位0xFE，后续四个字节才是真正保存长度)
encoding  //记录节点的content属性所保存数据类型以及长度(1,2,5字节可选)
content // 可以是一个字节数组也可以是一个整数。
```

可以通过`previous_entry_length`来反向遍历节点。

### 连锁更新
当新增或删除一个节点后，引起下一个节点中`previous_entry_length`字段从1字节增长为5字节，导致下一个节点长度大于等于254，将导致后续节点同样进行扩展，这一连续多次空间扩展操作称之为连锁更新。

连锁更新，最坏情况下，对压缩列表执行N次空间重分配，每次分配的最坏时间复杂度为O(N)，所以连锁更新的最坏时间复杂度是O(N)。

但其实在实际中，节点恰好有多个连续介于250-253字节之间的并不多。因此即使出现连锁更新，更新的节点数目不会特别多。

因此ziplistPush等命令的时间复杂度为O(N)。

### 压缩列表总结
1. 压缩列表是一种为节约内存而开发的顺序型数据结构。
2. 压缩列表被用作列表键和哈希键的底层实现之一。
3. 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或整数值。
4. 添加新节点到压缩列表，或从压缩列表中删除节点，可能会引发连锁更新操作。

## 对象
字符串对象、哈希对象、列表对象、集合对象、有序集合对象。

Redis的对象系统还实现了基于引用计数技术的内存回收机制，当程序不再使用某个对象的时候，这个对象所占用的内存就会被自动释放；另外，Redis还通过引用计数技术实现了对象共享机制，这一机制可以在适当的条件下，通过让多个数据库键共享同一个对象来节约内存。

### 对象类型及编码
当在Redis中创建一个键值对时，至少会创建两个对象，键对象和值对象。
```c++
typedef struct redisObject{
    unsigned type:4;  //类型
    unsigned encoding:4;   // 编码
    unsigned lru:LRU_BITS; // 
    int refcount; // 引用计数
    void* ptr; // 数据结构指针
} robj;
```

### 类型

`TYPE`命令返回结果为数据库键对应的值对象的类型，而不是键对象的类型。只有五种。

OBJECT ENCODING可以查看一个数据库键对应的值对象的编码。

### 编码与实现
encoding记录了对象所使用的编码，即这个对象使用了什么数据结构作为对象的底层实现。

| 编码常量                  | 底层数据结构    |
| ------------------------- | --------------- |
| REDIS_ENCODING_INT        | long类型的整数  |
| REDIS_ENCODING_EMBSTR     | embstr编码的SDS |
| REDIS_ENCODING_RAW        | SDS             |
| REDIS_ENCODING_HT         | 字典            |
| REDIS_ENCODING_LINKEDLIST | 双端链表        |
| REDIS_ENCODING_ZIPLIST    | 压缩列表        |
| REDIS_ENCODING_INTSET     | 整数集合        |
| REDIS_ENCODING_SKIPLIST   | 跳表和字典      |



STRING：整数值实现、embstr编码的SDS、以及SDS实现。

LIST：压缩列表、链表

HASH：压缩列表、字典

SET：整数集合、字典

ZSET：压缩列表、跳表+字典

### 字符串对象
若保存的是整数值，则可以用long类型来表示。

字符串值的长度大于32字节时，采用SDS来保存(RAW)。

字符串值的长度小于等于32时，采用embstr编码的SDS来保存。

RAW编码会调用两次分配函数分别创建RedisObject和sdshdr结构，而embstr通过调用一次内存分配函数来分配一块连续的空间，分别包含两个结构。释放同理。

embstr地址连续，缓存优势。

浮点数在Redis中同样是通过字符串值来保存的。

#### 编码转换
int型转换为raw。

embstr是只读的，不能进行修改。对其进行修改时，先将其编码从embstr转为raw，再执行修改命令。

### 列表对象
压缩列表或双端链表实现。

#### 编码转换
同时满足以下两个条件时，采用压缩列表编码，这两个值是可以修改的。
1. 列表对象保存的所有字符串元素的长度都小于64
2. 列表对象保存的元素数量小于512个

### 哈希对象
压缩列表或字典实现。

压缩列表始终保存新元素在队尾。键值对象时连续存放的，键对象在前，值对象在后。

#### 编码转换
同时满足以下两个条件，采用压缩列表编码，这两个值是可以修改的。
1. 列表对象保存的所有键值对的键和值的字符串长度都小于64
2. 列表对象保存的元素数量小于512个

### 集合对象
整数集合或字典

字典的值被设置为NULL。

#### 编码转换
当集合对象可以同时满足以下两个条件时，对象使用intset编码：
1. 集合对象保存的所有元素都是整数值；
2. 集合对象保存的元素数量不超过512个。

不能满足这两个条件的集合对象需要使用hashtable编码。

### 有序集合对象
压缩列表或跳表+字典

压缩列表集合元素从小到大排序，分值较小的靠近表头。

字典实现O(1)查找分值，跳表实现O(logN)查找元素，以及O(N)遍历执行范围操作。

#### 编码转换
当有序集合对象可以同时满足以下两个条件时，对象使用ziplist编码：

1. 有序集合保存的元素数量小于128个；
2. 有序集合保存的所有元素成员的长度都小于64字节；

不能满足以上两个条件的有序集合对象将使用skiplist编码。

### 类型检查和命令多态
命令分为两种，一种是可以对任何类型的键执行，如`DEL、EXPIRE、RENAME、TYPE、OBJECT`等。

一种是只能对特定类型的键执行，如：

1. 字符串键：`SET、GET、APPEND、STRLEN`等
2. 哈希键：`HDEL、HSET、HGET、HLEN`等
3. 列表键：`RPUSH、LPOP、LINSERT、LLEN`等
4. 集合键：`SADD、SPOP、SINTER、SCARD`等
5. 有序集合键：`ZADD、ZCARD、ZRANGK、ZSCORE`等

#### 类型检查
再执行一个类型特定命令前，会检查数据库键的值对象是否为执行命令所需的类型，否则拒绝执行并返回一个错误。

#### 多态命令的实现
同一命令对于不同编码的实现调用是不同的。

### 内存回收
引用计数来实现，当计数值为0时，所占用的内存会被释放。

### 对象共享
Redis只会共享整数值字符串对象以及Redis经常返回的一些命令响应字符串。包含字符串对象的其他对象同样会共享整数值对象。

对于字符串对象和包含字符串对象的其他对象，并不会进行共享，这是因为进行共享，首先需要判断二者是相同的，对于字符串对象时间复杂度为O(N)，对于其他包含字符串对象的时间复杂度为O(N^2)。

### 对象空转时长
`lru`记录了对象最后一次背命令程序访问的时间。当服务器占用内存超过maxmemory设置的上限时，空转时常较高的那部分键会优先被服务器释放。

# 单机数据库的实现
## 数据库
### 服务器中的数据库
Redis将所有数据库都保存在服务器状态`redisServer`结构的db数组中，db数组的每个项都是一个`redisDb`结构。

`dbnum`决定应该创建多少个数据库，默认选项值为16。

### 数据库切换
每个客户端都有自己的目标数据库，默认为0，可以通过select进行切换，`redisClient`中的db记录了当前的目标数据库。

```shell
select db_id //切换数据库
```

### 数据库键空间
Redis是一个key-value数据库，每个数据库都由`redisDb`结构表示，`redisDb`结构的dict字典保存了数据中的所有键值对，这个字典称为键空间。

键空间的每个键都是一个字符串对象，值可以是字符串对象、列表对象、哈希对象、集合对象和有序集合对象。

#### 键空间操作
`FLUSHDB`清空数据库，删除键空间中的所有键值对。
`RANDOMKEY`随即返回数据库中的某个键。
`DBSIZE`返回数据库中键数量。

#### 读写键空间时的维护操作
读写一个键后，会根据键是否存在更新服务器的键空间命中次数或miss次数。

读写一个键后，更新键的LRU。

在读写一个键时发现键国企，会先删除这个过期键，然后才执行余下操作。

`WATCH`监视某个键，当服务器对该键修改之后，会将这个键标记为脏，从而让事务程序注意到这个键已经被修改。

每修改一个键之后，都会对脏键计数器值增1，并触发服务器的持久化以及复制操作。

如果服务器开启了数据库通知功能，那么对键进行修改之后，服务器将按配置发送相应的数据库通知。

### 设置键的生存时间或过期时间
`EXPIRE/PEXPIRE`可以以秒或毫秒为精度为数据库的某个键设置生存时间(TTL)，在指定时间过后，服务器会自动删除生存时间为0的键。

`EXPIREAT/PEXPIREAT`可以以秒或毫秒为精度为数据库的某个键设置过期时间(TTL)，当过期时间来临时，服务器就会删除这个键。

`TTL/PTTL`可以接受一个带有生存时间或过期时间的键，返回这个键的剩余生存时间。

SETX可以设置一个字符串键的同时为键设置过期时间。

#### 设置过期时间
`EXPIRE<key><ttl>`命令用于将键key的生存时间设置为ttl秒。

`PEXPIRE<key><ttl>`命令用于将键key的生存时间设置为ttl毫秒。

`EXPIREAT<key><timestamp>`命令用于将键key的过期时间设置为timestamp所指定的秒数时间戳。

`PEXPIREAT<key><timestamp>`命令用于将键key的过期时间设置为timestamp所指定的毫秒数时间戳。

都是通过`PEXPIREAT`命令来实现的。

#### 保存过期时间
redisDb的expires字典保存了数据库中所有键的过期时间。

过期字典的键是一个指针，指针指向键空间中的某个键对象。

值是一个long long类型的整数，保存了数据库的过期时间，一个毫秒精度的UNIX时间戳。

#### 移除过期时间
`PERSIST`移除一个键的过期时间。

`TTL/PTTL`分别以秒和毫秒为单位返回键的剩余生存时间。

#### 过期键的判定
1. 检查给定键是否存在于过期字典，若存在，则取得过期时间。
2. 检查当前UNIX时间戳是否大于过期时间，若是则已过期，否则未过期。

#### 过期键删除策略
1. 定时删除
    创建定时器，过期时间来临时，立即执行删除操作，对内存友好，对CPU不友好，并且定时器实现依赖于时间事件和无序链表，查找效率低。
2. 惰性删除
    访问键的时候在进行国企检查，CPU友好，对内存不友好。
3. 定期删除
    每隔一段时间执行一次删除过期操作，通过限制删除操作执行时长和频率来减少对CPU时间的影响。

Redis采用的是惰性删除+定期删除。

### AOF、RDB和复制功能对过期键的处理
#### 生成RDB文件
在执行`SAVE/BGSAVE`时会创建一个新的RDB文件，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。

#### 载入RDB文件
若服务器开启了RDB功能， 那么服务器将对RDB进行载入。

如果服务器以主服务器模式运行，那么在载入RDB时，会对文件中保存的键进行检查，未过期的键会被载入，过期会被忽略。

如果服务器以从服务器模式运行，保留所有键，因为主从服务器在数据同步时，从服务器数据库会被清空。

#### AOF写入
当服务器以AOF持久化模式运行时，若某个键过期，还没有被删除，那么AOF文件不会因为这个过期键产生任何影响。

当过期键被删除后，程序会向AOF文件追加一条DEL命令。

#### AOF重写
在执行AOF重写过程中，会对键进行检查，过期键不会保存到重写后的AOF文件中。

#### 复制
当服务器运行在复制模式下，从服务器的过期键删除动作由主服务器控制。

主服务器在删除一个过期键后，会显式地向所有从服务器发送一条DEL命令，从而告知从服务器删除过期键。

从服务器在执行客户端的读命令时，不会处理过期键，一律按照非过期来处理。

只有接收到主服务器的DEL命令后，才会删除过期键。

保证了主从服务器的一致性，即使是过期。

### 数据库通知
客户端通过订阅给定的频道来获取数据库中键的变换以及命令执行情况。



# RDB持久化
`SAVE`阻塞Redis服务器，直到RDB文件创建完为止，不能处理任何命令请求。
`BGSAVE`命令派生出一个子进程，由子进程负责创建RDB文件，父进程继续处理命令请求。

因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：
1. 如果服务器开启了AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态。
2. 只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。


## RDB总结
1. RDB用于保存和还原Redis服务器所有数据库中的所有键值对数据。
2. SAVE阻塞，BGSAVE由子进程执行保存操作。
3. SAVE设置的保存条件，一个满足机会执行BGSAVE。
4. RDB是一个经过压缩的二进制文件。
5. 对于不同类型的键值对，RDB会使用不同的方式来保存。

# AOF持久化
AOF持久化通过保存Redis服务器所执行的写命令来记录数据库状态。

被写入AOF文件的所有命令都是以Redis的命令请求协议格式保存的，纯文本格式。

## AOF持久化的实现

## AOF重写
为了解决AOF文件过大的问题，Reids可以创建一个新的AOF文件来替代现有的AOF文件。

原理：从数据库中读键的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令。若值的个数超过了一次性写语句的上限，就会用多条命令来记录键的值。

AOF重写期间，服务器需要执行三个动作：
1. 执行客户端命令
2. 将执行后的写命令追加到AOF缓冲区
3. 将执行后的写命令追加到AOF重写缓冲区

子进程完成AOF重写后，向父进程发送一个信号，父进程接收到信号后，进行
1. 将AOF重写缓冲区的内容写入到新AOF文件中，新AOF文件所保存的数据库状态和服务器当前数据库状态一致。
2. 对AOF文件改名，原子地覆盖现有AOF文件。

只有信号处理函数执行时，会使得服务器进程阻塞。
































# 事务
Redis通过`MULTI/EXEC/WATCH`来实现事务，`MULTI`为开始，`EXEC`为提交。

## 事务的实现
1. 事务开始
    `MULTI`可以将执行该命令的客户端从非事务状态切换至事务状态，将客户端状态的flags属性打开REDIS_MULTI标识完成。
2. 事务入队
    非事务状态的客户端发送的命令会被服务器立刻执行。而事务状态下，服务端会根据客户端发送的不同命令`EXEC/DISCARD/WATCH/MULTI`来执行。
3. 事务执行
    每个Redis客户端都有事务状态，保存在客户端状态的mstate属性里面，事务状态包含一个事务队列(multiCmd的数组)，以及一个已入队命令的计数器。

### 事务执行
1. `EXEC`
    EXEC命令会立刻被服务器执行，然后服务器会遍历该客户但的事务队列，执行队列中保存的所有命令，最后将执行命令的结果返回给客户端。
2. `WATCH`
    乐观锁，它可以在`EXEC`执行之前，监视任意数量的数据库键，并在`EXEC`命令执行时，检查被监视的键是否有至少一个被修改过了，如果有，则服务器拒绝执行事务，并向客户端返回代表事务执行失败的空回复。`SET/LPUSH/SADD`等命令在执行后，会检查`watched_keys`字典，查看是否有客户端正在监视刚刚被修改过的数据库键，若有则会将监视被修改键的客户端的`REDIS_DIRTY_CAS`标识打开，表示客户端的事务安全性已经被破坏。
3. 判断事务的安全性
    当服务器接收到一个客户端发来的`EXEC`命令时，服务器会根据这个客户端是否打开了REDIS_DIRTY_CAS标识来决定是否执行事务。
    若打开，说明客户端监视的键中，至少有一个被修改，服务器拒绝客户端提交的事务。若没有打开，则执行客户端提交的事务。
4. 完整的WATCH事务执行过程

### 事务的ACID
#### 原子性
若命令入队错误则该事务被服务器拒绝执行，所有的命令都不会执行。

Redis的事务不支持事务回滚机制，即使事务队列中的某个命令在执行期间出现了某个错误，整个事务也会继续执行下去，直到所有的命令都执行完毕。

若AOF模式下，事务执行过程中发生宕机，则服务器重启之前，可以使用redis-check-aof工具修复AOF文件，删除执行不完全的事务，再启动redis服务器。

#### 一致性
分三种情况，入队错误、执行错误和服务器停机。

命令入队错误，则拒绝执行整个事务。

执行错误，则该语句执行失败，其他语句不受影响。

服务器停机，无持久化时，数据库空白保持一致，RDB模式下，宕机可以通过RDB恢复保持一致性，AOF模式下，当即可以通过AOF恢复保持一致性。


#### 隔离性
Redis的服务器是单线程，因此事务保证不会中断，串行化方式执行。

#### 持久性
Redis事务使用队列封装了一组Redis命令，没有为事务持久化提供任何额外的功能，因此Redis事务的持久性完全由Redis的持久化模式决定。

未使用持久化下，不具有持久性。

RDB模式下，只有在满足特定条件时，才会执行BGSAVE，对数据库进行保存，并且异步执行的GBSAVE不能保证事务数据第一时间保存到硬盘中。

AOF下，如果appendfsync选项的值为always时，程序总会在执行命令之后调用同步函数，将命令数据真正地保存到硬盘中，因此是具有持久性。

AOF下，若appendfsync选项的值为everysec时，程序会每秒同步一次命令数据到硬盘，因为停机可能会恰好发生在等待同步的那一秒之内，可能造成事务数据丢失，不具备耐久性。




# Reids在游戏业务中的应用
游戏一般会使用mongoDB或者Mysql存储游戏信息，但数据存放在硬盘中，读取速度较慢，采用Redis，提高读写速度。

## Cache
Reids缓存简要信息如(在线状态、等级等部分信息)。

## 业务状态
数据量较小，或数据量较大但数据访问频率特别高。

## 避免大Key
大Key表示一个Key对应的value非常大，比如记录玩家的当前在线状态，用一个key为`online_status`的hashmap存储了所有玩家的在线信息`uid:status`。应当拆分为每个玩家做成一个`key-value`的方式，key为`online_status_{uid}`，value为是否在线。原因是Redis是基于Key来做分布式的，若创建了一个大Key，会导致分布式功能失效，所有的请求都会到达同一个Redis节点。

无法检测。

## 避免HotKey
某个Key读写频率很高，繁忙。可以检测。