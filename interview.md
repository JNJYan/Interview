[TOC]
# C++
## C++11特性
### 右值引用
先介绍一下左值右值，左值是指能够获取到地址的值，能否用取地址运算符获得对象的内存地址，对于临时对象，存储与寄存器中，是没有办法调用
右值引用的作用是来实现移动语义和完美转发
#### 移动语义
解决对象的资源所有权转移问题，

## 概念
### 编译
1. 预处理
   展开头文件，宏替换，删除注释、条件编译

2. 编译
   检查语法生成汇编，文件后缀为`.s`

3. 汇编
   将汇编转为机器码，文件后缀为`.o`

4. 链接
   链接至一起生成可执行程序

### OOP
三大特性：封装、继承、多态。
1. 封装：将内部的实现细节和数据成员隐藏起来，外部对象只通过留好的接口进行访问和调用，保证了内部数据地安全性，也隐藏了复杂的实现细节，当内部实现发生变化时，对外部影响较小。C++类的成员函数和数据成员的访问类型有三种，public、private、protected。
2. 继承：如果子类属于父类的一种，拥有父类的所有属性和方法，就不需要编写相同的代码，实现复用。
3. 多态：可以用相同的方式根据不同的对象执行不同的操作，C++里允许将父类的指针和引用指向一个子类对象，从而根据具体的对象类型，来调用不同的方法，是通过虚函数实现的。如果某一个方法要被子类所重写，就要将该方法声明为虚方法。

### 静态链接/动态链接
1. 静态链接：由链接器将库的内容加入到可执行程序中，将要调用的函数链接到可执行文件中，成为可执行文件的一部分。
2. 动态链接：没有加入到可执行文件中，而是加入了调用函数的描述信息(重定位)，程序运行时采取建立链接关系，`.dll`。

### 静态库/动态库
1. 静态库：windows下`.lib`，linux下`.a`
2. 动态库：windows下`.dll`，linux下`.so`

### 静态编译/动态编译
静态编译：提取库中需要的部分，链接到可执行文件中，会被重复装载，浪费内存，如果有静态库需要更新，则程序需要重新编译。
动态编译：依赖于外部动态库，在运行时去调用，库更新时，不需要重新编译。

### 堆栈溢出
1. 栈溢出
递归调用次数过多导致的，通过尾递归来解决。

2. 堆溢出
缓冲区溢出，写操作超出缓冲区范围，覆盖了已有数据。



## 对比
### sizeof/strlen
`sizeof`：运算符，编译时已经计算好了，返回的是字符数组在内存中占用的空间，包含末尾空字符`\0`，当给定函数时，返回函数返回类型占用空间的大小，给定指针时，返回指针的大小。
`strlen`：库函数，返回的是字符串的长度即有效字符的个数，从给定地址遍历直到遇到`\0`。

### new/malloc
1. `new`是一个关键字，只需要编译器支持，而`malloc`是一个库函数，需要引入头文件。
2. `new`从自由存储区分配空间，而`malloc`只能从堆上分配空间。
3. `new`分配空间只需要指定类型和个数，而`malloc`需要指定具体分配的空间大小。
4. `new`直接返回指定类型的指针，而`malloc`返回`void *`指针，需要进行强制转换。
5. `new`分配失败返回`bad_alloc`异常，而`malloc`返回空指针。
6. `new`分配对象内存时，三个过程，第一步调用`operator new`分配空间，第二步调用类型的构造函数在分配的空间上创建对象，第三步，将指针指向该对象。
7. `new`分配的要调用`delete`释放，会执行析构函数，而`malloc`通过`free`释放。
8. `new`和`delete`可以被重载，而`malloc/free`虽然是函数但不能被重载。

### 指针/引用
1. 指针是一个拥有实际内存空间的一个对象，相当于一个变量，存储的是一个地址，而引用只是变量的一个别名。
2. 引用在声明的时候必须完成初始化，不能为空，而指针可以先声明，再为其初始化，指针也可以为空。
3. 引用是不能更改的，而指针则可以指向不同的对象。
4. sizeof(引用)得到的是对象的大小，而sizeof(指针)是指针本身的大小。
5. 引用本身就是就是该对象，而指针本身的内容是对象的地址，需要对其解引用才能获取对象。
6. 自增，引用自增等同于变量自增，指针自增，相当于指向的地址发生变化。
7. 作为形参时，指针我们需要实现判断是否为空，而引用不需要。

## 关键字

### inline
建议编译器进行内联优化，不能包含复杂的结构控制语句，如循环、switch，不能递归。
在定义类内部定义的函数，默认是inline的。

### static
1. 修饰全局变量和全局函数，作用为当前文件
2. 修饰局部变量，持久化
3. 修饰成员变量和成员函数，属于类而非对象，静态方法中不能调用非静态方法，非静态方法可以调用静态方法和访问静态成员。可也通过对象调用，也可以通过类调用。

### const
1. 声明一个常量
2. 指向变量的常量指针`int * const`与指向常量的指针`const int *`
3. 类中修饰函数，修饰的是this指针，该方法不能改变成员，但可以通过`mutable`使成员变量可以更改，不能调用非const函数
4. 修饰传入的引用或指针形参
5. 修饰返回的指针或引用，保护指针指向的内容或引用的内容不被修改

### short/long
![img](https://img-blog.csdn.net/20130913163641750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2t5X3Fpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
只有`long`和指针的大小会因机器位数改变。




# 计算机网络
## 网络模型
### TCP
物理层、数据链路层、网络层、传输层、应用层

### OSI
物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

### 为什么要分层
1. 各层之间相互独立，高层不需要知道底层功能是如何实现的，只需要调用底层的接口就可以。

2. 内部变化对外部不可见，不会对其他层产生影响。

3. 易于实现和标准化，将复杂的网络通信分解为一系列的功能模块。

## 传输层协议
### TCP/UDP
1. TCP和UDP都是计算机网路中传输层的一种协议。
2. TCP是面向字节流的，将上层交付的数据包以字节流的形式发送，而UDP是基于数据报的。
3. TCP是面向连接的，在传输数据时需要在通信双方建立连接三次握手，断开连接三次挥手。而UDP是无连接的。
4. TCP可靠连接是因为TCP通过序号确认、重传机制来保证了数据无差错，不重复，不丢失，而UDP尽最大努力交付，不保证可靠。
5. TCP在传输过程中存在拥塞控制，而UDP不存在拥塞控制，虽然可能会有部分数据丢失，但其适用于对时延要求较高的某些场景，但在有些场景下也有可能会引起网络产生严重的拥塞问题。
6. TCP是一种点到点的通信只能一对一，而UDP支持一对多、多对多的方式。

### UDP
UDP有两个字段：数据字段和首部字段。
UDP最大报文段长度65535

#### 首部字段
首部字段只有八个字节。
1. 源端口
2. 目的端口
3. 长度，最小值为8，只有头部
4. 校验和(加入伪首部计算)

### TCP
1. TCP是一种面向连接的传输层协议，应用程序在使用TCP传输数据前必须建立连接，结束之后也要断开连接。
2. TCP传输是可靠的，保证分组无差错不丢失、不重复。主要是同学序号确认和重传机制来实现的。
3. TCP是一种全双工通信，因为设有接收和发送缓存，因此连接的两端可以在同一时刻发送数据或接收数据。
4. TCP是一种面向字节流的通信，对于应用层交付的数据分组，均看作一串无结构的字节流，可能会导致粘包问题。
5. TCP连接是点到点，只支持一对一的通信。

#### 首部字段
固定首部字段20个字节，可变长度为40字节，整个首部最长为60字节
1. 源端口/目的端口
2. 序号 4字节
3. 确认号 4字节
4. 数据偏移 4位
5. 保留字 6位
6. 标志位 6位
   紧急URG、确认ACK、推送PSH、复位RST、同步SYN，终止FIN
7. 窗口 2字节
8. 校验和 2字节
9. 紧急指针 2字节

#### TCP报文长度
TCP报文数据段长度最大MSS，默认为536字节，此长度不包含首部。


#### TCP三次握手、四次挥手
![三次握手](https://static001.geekbang.org/resource/image/65/29/65cef2c44480910871a0b66cac1d5529.png)
![四次挥手](https://static001.geekbang.org/resource/image/b8/ea/b8911347d23251b6b0ca07c6ec03a1ea.png)

#### 可靠传输
##### 停止等待协议
发送方发一个等一个确认，超时重传。

##### 连续ARQ协议
发送方接收到确认之后，向前移动窗口。
接收方累计确认，对按序到达的最后一个分组发送确认。缺点在于若丢失了中间一个分组，发送方会重发丢失分组之后的所有分组(GoBackN)。

##### 选择确认
为了解决累计确认中，对丢失分组后的数组的重复发送问题，提出SACK选择确认。

在TCP连接建立时，在首部加入允许SACK选项，在可变长度中记录不连续区域的上边界和下边界。每个边界需要4个字节，另需要一个字节指明是SACK，一个字节指明需要占用多少字节，最多只能指明四个字节块的边界信息，每个字节块两个边界，4*8+2=34

#### 滑动窗口实现流量控制
发送窗口不应超过接收窗口的大小，TCP窗口单位是字节。

1. Nagle算法
   若发送方应用进程要把发送的数据逐字节地送到TCP发送缓存，则发送方就将第一个数据字节先发送，将后面的字节缓存起来，当发送方接收到第一个字节的确认后，再将发送缓存的所有数据组装成一个报文段发送出去。同时对之后的数据进行缓存，即只有在接受到前一个报文段的确认后才发送下一个报文段。当待发送的数据已经达到发送窗口的一半或已经达到报文段的最大长度时，就立刻发送一个报文段。

#### 拥塞控制
流量控制是端对端的问题，只需要由接收端和发送端来决定，通过抑制发送端的发送速率是的接收端来得及接受。

拥塞控制是由网络拥塞程度决定的。

swnd = min[rwnd, cwnd]

基于窗口的拥塞孔，发送方维持一个拥塞窗口cwnd，大小取决于网络的拥塞程度。

只要发送方没有按时接收到应当到达的确认报文，即出现了超时，就认为网络出现了拥塞。

1. 慢开始
由小到大增大拥塞窗口，指数增长，慢并不是指增长速度慢，而是指初始拥塞窗口大小很小。

需要设置一个慢开始门限ssthresh，当cwnd小于ssthresh时，使用慢开始，当cwnd大于ssthresh时，使用拥塞避免，相等时，无所谓。

超时后，ssthresh设置位拥塞窗口的一半。

2. 拥塞避免
线性增长(加法增大)

3. 快重传
要求接收方不要等到自己发送数据时捎带确认，而是要立即发送确认，即使收到了失序的报文段也要立即发出对已收到报文段的重复确认。
例如在接收到报文段M1，M2，分别要发送其确认号，接下来收到了M4报文段，此时就要重复确认M2三次。

4. 快恢复
一旦发生快重传，发送方将门限值ssthresh设置为拥塞窗口的一半，拥塞窗口也设置一半，并执行拥塞避免算法。(乘法减小)


#### TCP粘包
发送方发出的若干数据包被接收方接收时按照一个数据包接收了。

产生原因：
1. 发送方，TCP有一个Nagle算法来处理小分组，为了保证不频繁地发送小分组，Nagle算法只有在上一个分组得到确认时，才会发送下一个分组，且会将多个小分组合并到一起一同发送。
2. 接收方收到分组之后，没有及时的进行处理，先将分组放到接收缓存中，当TCP接收分组的速度大于应用层读取速度时，就会在缓
冲区中存在多个分组。

解决方法：
1. 在数据包头部加入数据包长度字段。
2. 在数据末尾增加分割符`\r\n`

## 应用层协议
### DNS
基于UDP，端口号53

![image-20200707142641994](C:\Users\May\AppData\Roaming\Typora\typora-user-images\image-20200707142641994.png)

- 根域名服务器
所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。本地域名服务器若堆互联网上任何一个域名无法解析，首先求助于根域名服务器。
- 顶级域名服务器
负责管理在该顶级域名下注册的所有二级域名。
- 权限域名服务器
- 本地域名服务器

![image-20200707145744083](C:\Users\May\AppData\Roaming\Typora\typora-user-images\image-20200707145744083.png)

主机向本地域名服务器的查询是递归查询，本地域名向根域名服务器的查询通常是采用迭代查询。

### FTP
基于TCP实现文件传输，使用C/S架构，控制端口号21，数据端口号20，建立两个TCP连接，控制连接在会话期间一直保持打开。

FTP服务器进程采用Reactor模型。

### TFTP
简单文件传输协议，可以基于UDP。

### TELNET
远程终端协议，基于TCP连接远程主机，可以将用户的输入传到远程主机，C/S架构。

### HTTP
- URL
统一资源定位符，<协议>://<主机>:<端口>/<路径>

- URL
统一资源标识符

#### 基本概念

HTTP基于TCP协议，保证数据的可靠传输，端口号80。

HTTP协议本身是无连接，即同一个客户第二次访问同一个服务器上页面时，服务器响应与第一次访问时相同。

HTTP/1.0只支持短连接，每次发出http请求都会经历创建TCP连接、发送资源、断开TCP连接的过程。

HTTP/1.1引入长连接，`keep-alive`，保持TCP连接一定的时间。分为两种，一种是非流水线方式，一种是流水线方式，流水线方式可以在未收到响应报文时继续发送请求报文。

#### 报文结构
1. 请求报文
   1. 请求行
   2. 请求头
   3. 请求正文
   
2. 响应报文
   1. 状态行
   2. 响应头
   3. 响应正文

#### 请求方法
1. GET
请求读取指定url页面的信息，返回主体。

2. POST
向指定资源提交数据并处理请求。

3. HEAD
请求读取指定url页面的信息的头。

4. PUT
在指明的url种存储数据。

5. DELETE
删除URL的资源，指定页面。

6. OPTION
请求一些选项信息。

7. CONNECT
代理服务器

#### GET/POST
1. 都包含请求头、请求行，POST多了body，用以存储提交的数据
2. GET多用于查询，参数放在url中，POST用来提交，内容放在body中。
3. GET提交的信息可以在url中直接看到，而POST放在报文中，用户无法直接看到，POST也可以在url中传递参数。
4. GET提交的数据长度有限制，因为url长度有限制，而POST没有

#### 响应状态码
1. 1xx信息型
   - 100 Continue
      服务器通知浏览器一切正常，请客户端继续请求。
   - 101 Switching Protocal
   
2. 2xx成功型
   - 200 OK
      请求成功
   - 201 Created
      常用于POST，PUT请求，表明请求成功
   - 202 Accepted
      请求已经接收到，但没有响应。
   
3. 3xx重定向
   - 300 Multiple Choice
      返回多个响应，需要浏览器或用户选择
   - 301 Moved Permanently
      永久重定向
   - 302 Found
      临时跳转

4. 4xx客户端错误
   - 400 Bad Request
      请求语法有问题
   - 401 UnAuthorized
      未授权
   - 403 Forbidden
      权限不足，服务器拒绝响应
   - 404 Not Found
      指定url不存在

5. 5xx服务端错误
   - 500 Internal Server Error
      服务器内部错误，未捕获
   - 502 Bad Gateway
      服务器作为网关时，收到上游服务器返回的无效响应
   - 503 Service Unavailable
      服务器无法服务，一般过一段时间会恢复正常。
   - 505 Http Version Not Supported
      发出的请求http版本服务器不支持

#### 请求头参数
1. Host
2. Connection
3. User-Agent
4. Accept-Language

#### Cookie
前面所述HTTP是无状态的，使用Cookie来跟踪用户。

当用户A访问某网站时，网站服务器为用户产生一个身份识别码作为索引存储在服务器后端数据库中即Session_id。并在给A的HTTP响应报文中添加一个`Set-cooke`的响应行，用户在接收之后，将Cookie存储于本地，当用户A再次访问该网站时，就会将该Cooke放入HTTP请求报文中。

Cookie的结构中有生存期、Cookie值，服务器哪些页面可以使用Cookie

#### Session
服务器端创建Session，用于跟踪用户，一般用Redis/Memcached存放。Session本身是一个抽象的概念。

#### HTTP缺点
1. 请求信息明文传输，不能保证机密性
2. 数据完整性未校验，易篡改
3. 服务端没有验证身份，易冒充

### HTTPS
端口号443
HTTP over Secure Socket Layer

HTTP + SSL/TSL

TSL(Transport Layer Security) 传输层安全，前身SSL，目前广泛使用TSL1.1和TSL1.2

#### HTTPS过程
![HTTPS](https://img2018.cnblogs.com/blog/1223518/201908/1223518-20190818111014781-1699339583.png)

#### HTTPS缺点
1. 多次握手，页面加载时间长
2. 连接缓存不如HTTP高效，有额外的数据开销
3. SSL证书昂贵
4. SSL涉及安全算法，占用CPU资源，对服务器资源消耗较大

### SMTP
简单邮件传输协议，端口号25，基于TCP

### POP3/IMAP
邮局协议3/网际报文存取协议


# 并发
### 进程 线程、协程
1. 进程是程序在操作系统中执行的实例，是操作系统进行资源分配和调度的基本单位，操作系统会为每个进程分配虚拟地址空间，32位机器上为4GB，地址空间分为内核区和用户区两部分，自高地址到低地址的第一个G为内核区，用户区依次为栈、堆、BSS段(未初始化的全局变量)、数据段、字符串常量区、代码区。进程之间地址空间是相互独立的。
2. 线程是操作系统程序执行的最小单位，一个进程可以拥有多个线程，即使没有显式创建一个线程，也会为进程分配一个主线程，同一个进程里的多个线程共用进程的内存空间(代码区、全局变量、堆)，但线程拥有自己的线程栈、程序计数器等，因为共享进程的内空间，所以线程之间的切换代价远远小于进程切换，进程和线程的切换都涉及用户态和内核态的转换。一个进程所拥有的线程数目由线程栈的大小和进程的用户区大小决定。
3. 协程是比线程更加轻量级的，一个线程可以拥有多个协程，协程完全由程序控制，只在用户态执行，协程切换不涉及用户态和内核态的转换，协程切换时机是由程序决定的而不是操作系统。本质上协程是一种特殊的函数，可以在某个地方挂起、恢复执行，线程中的协程只能串行执行。

### 进程状态
创建、就绪、执行、阻塞、终止

### 进程通信
1. 无名管道PIPE
只能用于父子进程通信，属于半双工通信，同一时刻只能存在单向的数据传输，通常是由父进程创建一个pipe，然后fork出的子进程同样有一个pipe句柄。是一种特殊的文件，只存在于内存中，不存在于文件系统。
2. 有名管道FIFO
能用于任意进程之间的通信，是存在于文件系统的一种文件，可以通过`mkfifo\mknod`方法创建，前者可以指明权限，后者需要用`chmod`重新指定权限。
3. 信号
只能传递有限的信息。
4. 消息队列
虽然叫做队列，但实际的数据结构是一个消息链表，由特定的格式和优先级，可以按类型进行读取。
5. 信号量
用于实现进程之间的互斥和同步，原子操作。
6. 共享内存
通常和信号量一起使用。
7. Socket
一种是本地Socket，一种是正常的

### 线程通信
1. 全局变量(临界区)
互斥量+条件变量来实现线程的互斥和同步
2. Message消息机制
`PostMessage`：异步，线程只能向主窗口发送消息
`SendMessage`：同步
`PostThreadMessage`：任意两个线程间通信
3. MFC中事件

### 

# 概念开放题
## C++/Python/Java
1. C++属于编译型语言，需要将源代码先编译成目标语言，然后通过链接程序连接生成的目标文件。
2. Python属于解释性语言，由解释器根据输入数据直接执行而不生成任何目标程序。不需要类型声明，语法简单，编程效率高。
3. Java属于混合型语言，也需要编译，但没有直接编译成机器码，而是编译为字节码，然后在JVM上用解释方式执行字节码。

## 从浏览器输入URL发生了什么
1. 在浏览器中输入url地址
2. dns解析过程
    1. 查询本机hosts是否有对应ip，若有则返回，若无则继续
    2. 若没有找到对应hosts，浏览器会发出一个dns请求到本地dns服务器(配置ip时配置的)
    3. 本地dns服务器首先查询缓存记录，若有则返回，若无继续
    4. 本地dns向根域名服务器查询
    5. 根域名服务器告知本地dns服务器该url的顶级域名服务器地址，本地dns去向顶级域名服务器发出请求
    6. 顶级域名服务器告知本地dns服务器该url得权限域名服务器地址，本地dns去查询，返回ip地址，并缓存。
    
3. 建立TCP连接，以随机端口(1024~65535)向服务器80端口建立TCP连接请求，三次握手
4. 发起HTTP请求
5. 服务端处理，返回数据
6. 关闭TCP连接
7. 浏览器解析数据
8. 浏览器渲染布局

## 

# Linux
## Linux常用信号
- `SIGHUP`: 用户终端连接结束时发出，默认终止进程。
- `SIGINT`: 程序终止(Interrupt)信号，在键入`Ctrl-C`时发出，通知前台进程终止。
- `SIGQUIT`: `Ctrl+\`发出，类似于SIGINT，进程退出时会产生core文件，类似于一个程序错误信号。
- `SIGTRAP`: 断点产生。
- `SIGSEGV`: 试图访问未分配给自己的内存，或试图向没有写权限的内存地址写数据。
- `SIGIO`: 文件描述符就绪。
- `SIGSYS`: 非法系统调用。
## glibc
是Linux系统中最底层的api，封装了Linux操作系统提供的系统服务，几乎任何运行库都会依赖于glibc


# 数据库
## 范式
1. 第一范式
强调数据表的原子性，所有的字段不可再分。

2. 第二范式
第一范式的基础上，消除非主属性对于码的部分函数依赖，即存在主键能够将记录唯一区分。

3. 第三范式
第二范式的基础上，消除非主属性对主属性的传递依赖，要求表中不能含其他表中已包含的非主关键字信息。

4. BCNF范式
第三范式基础上，消除主属性对主属性的传递依赖。

## 事务
### ACID
- A
   原子性
- C
   一致性，完整性约束
- I
   隔离性
- D
   持久性

### 隔离级别
- 脏读
读未提交级别内的，一个未提交事务的对数据的更改被其他事务看到。

- 不可重复读
一个事务，多次读同一记录，读出来的内容不一致。

- 幻读
一个事务对某一条件的记录进行了更改，但存在另一事务插入了一条数据，致使前者在提交之后再去读数据时，发现了新插入的数据，看起来好像没有更改成功，即幻读。

## NoSQL
Not Only SQL
1. K-V存储，解决关系数据库无法存储数据结构的问题，value可以是各种数据结构，缺点不支持完整的ACID，Redis，memecachedb
2. 文档数据库，解决关系数据库的强schema约束问题，存储的是json，数据字段的灵活性，适合电商筛选列表，不支持事务，无法实现join操作，MongoDB
3. 列式数据库，解决关系数据库大数据场景下的I/O问题，按照列存储数据，HBase
4. 全文搜索引擎：解决关系数据的全文搜索性能问题，倒排索引，Elasticsearch

# 设计模式
## 单例模式
### 懒汉
#### 线程安全-双判断+锁
```c++
class Singleton{
private:
   Singleton(){
      cout << "constructor called" <<endl;
   }
   Singleton(const Singleton&)=delete;
   Singleton& operator=(const Singelton&)=delete;
   static mutex mtx;
   static Singleton* ptr;
public:
   ~Singleton(){
      cout << "destructor called" <<endl;
   }
   Singleton* getInstance(){
      if(ptr == nullptr){
         lock_guard<mutex> lock(mtx);
         if(ptr == nullptr){
            ptr = new Singleton;
         }
      }
      return ptr;
   }
};
Singleton* Singleton::ptr = nullptr;
```
#### 线程安全-局部静态变量
```c++
class Singleton{
private:
   Singleton(){
      cout << "constructor called" <<endl;
   }
   Singleton(const Singleton&)=delete;
   Singleton& operator=(const Singelton&)=delete;
public:
   ~Singleton(){
      cout << "destructor called" <<endl;
   }
   Singleton& getInstance(){
      static Singleton ptr;
      return ptr;
   }
};

```
### 饿汉
```c++
class Singleton{
private:
   Singleton(){
      cout << "constructor called" <<endl;
   }
   Singleton(const Singleton&)=delete;
   Singleton& operator=(const Singelton&)=delete;
   static Singleton* ptr;
public:
   ~Singleton(){
      cout << "destructor called" <<endl;
   }
   Singleton* getInstance(){
      return ptr;
   }
};
Singleton* Singleton::ptr = new Singleton();
```

## 工厂
### 简单工厂
### 工厂方法
### 抽象工厂


# 算法
## rand5生成rand7
rand5()能生成1到5

首先证明，rand7可以实现rand5
$$
p(x=1) = 1/7 + (2/7)*(1/7) + (2/7)^2 * (1/7) + \dots \\
= (1/7)*(1+ (2/7) + (2/7)^2 + \dots)//等比数列 \\
= (1/7) * (1/(1-(2/7)))\\
= 1/5
$$
那么我们只要能通过rand5生成一个大于7的随机数生成器即可。
$$
rand25() = 5*(rand5()-1) + rand5()
$$
```python
def rand7():
   res = 25
   while(res>21):
      res = 5 * (rand5() - 1) + rand5()
   return res%7+1
```

## 输入一个正整数，求和等于这个正整数的全部正整数连续序列
