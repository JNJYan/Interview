<!--
 * @Author: JNJYan
 * @LastEditors: JNJYan
 * @Email: jjy20140825@gmail.com
 * @Date: 2020-07-07 00:01:08
 * @LastEditTime: 2020-07-07 16:04:10
 * @Description: Modify here please
 * @FilePath: /readingnote/面试.md
--> 

[TOC]
# C++
## C++11特性
### 右值引用
先介绍一下左值右值，左值是指能够获取到地址的值，能否用取地址运算符获得对象的内存地址，对于临时对象，存储与寄存器中，是没有办法调用
右值引用的作用是来实现移动语义和完美转发
#### 移动语义
解决对象的资源所有权转移问题，
## 概念
### 编译
1. 预处理
展开头文件，宏替换，删除注释、条件编译
2. 编译
检查语法生成汇编，文件后缀为`.s`
3. 汇编
将汇编转为机器码，文件后缀为`.o`
4. 链接
链接至一起生成可执行程序

### OOP
三大特性：封装、继承、多态。
1. 封装：将内部的实现细节和数据成员隐藏起来，外部对象只通过留好的接口进行访问和调用，保证了内部数据地安全性，也隐藏了复杂的实现细节，当内部实现发生变化时，对外部影响较小。C++类的成员函数和数据成员的访问类型有三种，public、private、protected。
2. 继承：如果子类属于父类的一种，拥有父类的所有属性和方法，就不需要编写相同的代码，实现复用。
3. 多态：可以用相同的方式根据不同的对象执行不同的操作，C++里允许将父类的指针和引用指向一个子类对象，从而根据具体的对象类型，来调用不同的方法，是通过虚函数实现的。如果某一个方法要被子类所重写，就要将该方法声明为虚方法。

### 静态链接/动态链接
1. 静态链接：由链接器将库的内容加入到可执行程序中，将要调用的函数链接到可执行文件中，成为可执行文件的一部分。
2. 动态链接：没有加入到可执行文件中，而是加入了调用函数的描述信息(重定位)，程序运行时采取建立链接关系，`.dll`。

### 静态库/动态库
1. 静态库：windows下`.lib`，linux下`.a`
2. 动态库：windows下`.dll`，linux下`.so`

### 静态编译/动态编译
静态编译：提取库中需要的部分，链接到可执行文件中，会被重复装载，浪费内存，如果有静态库需要更新，则程序需要重新编译。
动态编译：依赖于外部动态库，在运行时去调用，库更新时，不需要重新编译。

## 对比
### sizeof/strlen
`sizeof`：运算符，编译时已经计算好了，返回的是字符数组在内存中占用的空间，包含末尾空字符`\0`，当给定函数时，返回函数返回类型占用空间的大小，给定指针时，返回指针的大小。
`strlen`：库函数，返回的是字符串的长度即有效字符的个数，从给定地址遍历直到遇到`\0`。
### new/malloc
1. `new`是一个关键字，只需要编译器支持，而`malloc`是一个库函数，需要引入头文件。
2. `new`从自由存储区分配空间，而`malloc`只能从堆上分配空间。
3. `new`分配空间只需要指定类型和个数，而`malloc`需要指定具体分配的空间大小。
4. `new`直接返回指定类型的指针，而`malloc`返回`void *`指针，需要进行强制转换。
5. `new`分配失败返回`bad_alloc`异常，而`malloc`返回空指针。
6. `new`分配对象内存时，三个过程，第一步调用`operator new`分配空间，第二步调用类型的构造函数在分配的空间上创建对象，第三步，将指针指向该对象。
7. `new`分配的要调用`delete`释放，会执行析构函数，而`malloc`通过`free`释放。
8. `new`和`delete`可以被重载，而`malloc/free`虽然是函数但不能被重载。

## 关键字

### inline
建议编译器进行内联优化，不能包含复杂的结构控制语句，如循环、switch，不能递归。
在定义类内部定义的函数，默认是inline的。

### static
1. 修饰全局变量和全局函数，作用为当前文件
2. 修饰局部变量，持久化
3. 修饰成员变量和成员函数，属于类而非对象，静态方法中不能调用非静态方法，非静态方法可以调用静态方法和访问静态成员。可也通过对象调用，也可以通过类调用。

### const
1. 声明一个常量
2. 指向变量的常量指针`int * const`与指向常量的指针`const int *`
3. 类中修饰函数，修饰的是this指针，该方法不能改变成员，但可以通过`mutable`使成员变量可以更改，不能调用非const函数
4. 修饰传入的引用或指针形参
5. 修饰返回的指针或引用，保护指针指向的内容或引用的内容不被修改

### short/long
![img](https://img-blog.csdn.net/20130913163641750?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvU2t5X3Fpbmc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
只有`long`和指针的大小会因机器位数改变。

# 计算机网络
### TCP
物理层、数据链路层、网络层、传输层、应用层

### OSI
物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

## 协议
### TCP/UDP
1. TCP和UDP都是计算机网路中传输层的一种协议。
2. TCP是面向字节流的，将上层交付的数据包以字节流的形式发送，而UDP是基于数据报的。
3. TCP是面向连接的，在传输数据时需要在通信双方建立连接三次握手，断开连接三次挥手。而UDP是无连接的。
4. TCP可靠连接是因为TCP通过序号确认、重传机制来保证了数据无差错，不重复，不丢失。

### UDP
1. UDP数据包长度为65535
### TCP三次握手、四次挥手
### TCP粘包
发送方发出的若干数据包被接收方接收时按照一个数据包接收了。

产生原因：
1. 发送方，TCP有一个Nagle算法来处理小分组，为了保证不频繁地发送小分组，Nagle算法只有在上一个分组得到确认时，才会发送下一个分组，且会将多个小分组合并到一起一同发送。
2. 接收方收到分组之后，没有及时的进行处理，先将分组放到接收缓存中，当TCP接收分组的速度大于应用层读取速度时，就会在缓
冲区中存在多个分组。

解决方法：
1. 在数据包头部加入数据包长度字段。
2. 在数据末尾增加分割符`\r\n`

### DNS
![image-20200707142641994](C:\Users\May\AppData\Roaming\Typora\typora-user-images\image-20200707142641994.png)

- 根域名服务器
所有的根域名服务器都知道所有的顶级域名服务器的域名和IP地址。本地域名服务器若堆互联网上任何一个域名无法解析，首先求助于根域名服务器。
- 顶级域名服务器
负责管理在该顶级域名下注册的所有二级域名。
- 权限域名服务器
- 本地域名服务器

![image-20200707145744083](C:\Users\May\AppData\Roaming\Typora\typora-user-images\image-20200707145744083.png)

主机向本地域名服务器的查询是递归查询，本地域名向根域名服务器的查询通常是采用迭代查询。

### FTP
基于TCP实现文件传输，使用C/S架构，控制端口号21，数据端口号20，建立两个TCP连接，控制连接在会话期间一直保持打开。

FTP服务器进程采用Reactor模型。

### TFTP
简单文件传输协议，可以基于UDP。

### TELNET
远程终端协议，基于TCP连接远程主机，可以将用户的输入传到远程主机，C/S架构。


### HTTP
- URL
统一资源定位符，<协议>://<主机>:<端口>/<路径>

HTTP基于TCP协议，保证数据的可靠传输，HTTP协议本身是无连接，

### HTTPS


# 并发
### 进程 线程、协程
1. 进程是程序在操作系统中执行的实例，是操作系统进行资源分配和调度的基本单位，操作系统会为每个进程分配虚拟地址空间，32位机器上为4GB，地址空间分为内核区和用户区两部分，自高地址到低地址的第一个G为内核区，用户区依次为栈、堆、BSS段(未初始化的全局变量)、数据段、字符串常量区、代码区。进程之间地址空间是相互独立的。
2. 线程是操作系统程序执行的最小单位，一个进程可以拥有多个线程，即使没有显式创建一个线程，也会为进程分配一个主线程，同一个进程里的多个线程共用进程的内存空间(代码区、全局变量、堆)，但线程拥有自己的线程栈、程序计数器等，因为共享进程的内空间，所以线程之间的切换代价远远小于进程切换，进程和线程的切换都涉及用户态和内核态的转换。一个进程所拥有的线程数目由线程栈的大小和进程的用户区大小决定。
3. 协程是比线程更加轻量级的，一个线程可以拥有多个协程，协程完全由程序控制，只在用户态执行，协程切换不涉及用户态和内核态的转换，协程切换时机是由程序决定的而不是操作系统。本质上协程是一种特殊的函数，可以在某个地方挂起、恢复执行，线程中的协程只能串行执行。

### 进程状态
创建、就绪、执行、阻塞、终止

### 进程通信
1. 无名管道PIPE
只能用于父子进程通信，属于半双工通信，同一时刻只能存在单向的数据传输，通常是由父进程创建一个pipe，然后fork出的子进程同样有一个pipe句柄。是一种特殊的文件，只存在于内存中，不存在于文件系统。
2. 有名管道FIFO
能用于任意进程之间的通信，是存在于文件系统的一种文件，可以通过`mkfifo\mknod`方法创建，前者可以指明权限，后者需要用chmod重新指定权限。
3. 信号
只能传递有限的信息。
4. 消息队列
虽然叫做队列，但实际的数据结构是一个消息链表，由特定的格式和优先级，可以按类型进行读取。
5. 信号量
用于实现进程之间的互斥和同步，原子操作。
6. 共享内存
通常和信号量一起使用。

### 线程通信
1. 全局变量(临界区)
互斥量+条件变量来实现线程的互斥和同步
2. Message消息机制
`PostMessage`：异步，线程只能向主窗口发送消息
`SendMessage`：同步
`PostThreadMessage`：任意两个线程间通信

### 

# 概念开放题
## C++/Python/Java
1. C++属于编译型语言，需要将源代码先编译成目标语言，然后通过链接程序连接生成的目标文件。
2. Python属于解释性语言，由解释器根据输入数据直接执行而不生成任何目标程序。不需要类型声明，语法简单，编程效率高。
3. Java属于混合型语言，也需要编译，但没有直接编译成机器码，而是编译为字节码，然后在JVM上用解释方式执行字节码。

## 从浏览器输入URL发生了什么
1. 在浏览器中输入url地址
2. dns解析过程
    1. 查询本机hosts是否有对应ip，若有则返回，若无则继续
    2. 若没有找到对应hosts，浏览器会发出一个dns请求到本地dns服务器(配置ip时配置的)
    3. 本地dns服务器首先查询缓存记录，若有则返回，若无继续
    4. 本地dns向根域名服务器查询
    5. 根域名服务器告知本地dns服务器该url的顶级域名服务器地址，本地dns去向顶级域名服务器发出请求
    6. 顶级域名服务器告知本地dns服务器该url得权限域名服务器地址，本地dns去查询，返回ip地址，并缓存。
    
3. 建立TCP连接，以随机端口(1024~65535)向服务器80端口建立TCP连接请求，三次握手
4. 发起HTTP请求
5. 服务端处理，返回数据
6. 关闭TCP连接
7. 浏览器解析数据
8. 浏览器渲染布局

## 

# Linux
## Linux常用信号
`SIGHUP`: 用户终端连接结束时发出，默认终止进程。
`SIGINT`: 程序终止(Interrupt)信号，在键入`Ctrl-C`时发出，通知前台进程终止。
`SIGQUIT`: `Ctrl+\`发出，类似于SIGINT，进程退出时会产生core文件，类似于一个程序错误信号。
`SIGTRAP`: 断点产生。
`SIGSEGV`: 试图访问未分配给自己的内存，或试图向没有写权限的内存地址写数据。
`SIGIO`: 文件描述符就绪。
`SIGSYS`: 非法系统调用。
## glibc
是Linux系统中最底层的api，封装了Linux操作系统提供的系统服务，几乎任何运行库都会依赖于glibc


# 数据库
## NoSQL
Not Only SQL
1. K-V存储，解决关系数据库无法存储数据结构的问题，value可以是各种数据结构，缺点不支持完整的ACID，Redis，memecachedb
2. 文档数据库，解决关系数据库的强schema约束问题，存储的是json，数据字段的灵活性，适合电商筛选列表，不支持事务，无法实现join操作，MongoDB
3. 列式数据库，解决关系数据库大数据场景下的I/O问题，按照列存储数据，HBase
4. 全文搜索引擎：解决关系数据的全文搜索性能问题，倒排索引，Elasticsearch